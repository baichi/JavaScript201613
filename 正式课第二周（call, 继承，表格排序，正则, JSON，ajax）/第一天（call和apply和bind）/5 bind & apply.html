<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
</body>
</html>
<script>
    'use strict';
    console.dir(Function.prototype); // call apply bind
    function fn(n1,n2,n3){
        console.log(this);
        // n1,n2,n3 => 100 ,200 ,300
    }

    //fn(); // window
    //fn.call(document.body,100,200,300); // body

    /*
    *   apply的用法: 用法和call基本相同。都是用来修改this关键字的
    *       不同: 传给调用apply的那个函数实例参数的方式不同,apply第二个参数是一个数组。是把数组里的每一项当作参数传给调用apply的函数的。
    * */
    function fn(n1,n2,n3){
        console.log(this);
        // n1,n2,n3 => 100 ,200 ,300
        console.log(n1 + n2 + n3);
    }
    var ary = [100,200,300]; //
    fn.apply(null,ary); // this => window
    fn.apply(undefined,ary); // this => window
    //fn.apply(null,[100,200,300]);
    /*
    *   'use strict' 使用严格模式解析以下代码:
    *       1 call和apply修改this的时候，在非严格模式下如果修改成null或者undefined那么浏览器会默认修改成window。但是在严格模式下null和undefined不变。
    *       2 在严格模式下，自运行函数中的this也不是window，是undefined
    *       3 在严格模式下，函数执行的时候如果前面没有"."那么函数中的this默认是undefined.在非严格模式下是window
    *       ... 百度
    * */
    (function (){
        console.log(this);
    })();



    ///&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&
    Function.prototype.bind;  // bind方法是不兼容低版本ie

    function sum(num1,num2){
        console.log(this);
        console.log(num1 + num2);
    }

    var res = sum.bind(document.body/*,1000,2000*/); // 只改this
    //console.log(res === sum); // false => 返回了一个修改了this的新函数
    res(1000,2000); //执行的时候再传参数
    res(4000,5000);
    // 后期我们自己写一个兼容的bind方法


    /*
    *   bind的用法: 都是用来修改this关键字的
    *       1 区别于call和apply，bind是返回一个处理好this的新函数
    *       2 返回值函数需要通过自己来执行。在执行的时候再传参数 res()
    * */













</script>